(*** From the standard lib ***)
module Proving

open FStar.List.Tot

(* Some syntactic sugar *)
let nil = []
let cons x xs = x :: xs

let l0 = 1 :: 2 :: 3 :: []

(*+ Discriminators : Nil?, Cons? +*)
(*! Nil? l0 ~> false !*)
(*! Cons? l0 ~> true !*)

(******************************************************************************)
(*** Off with their heads ***)
(* What about getting the tail of a list ? *)
let tail0 (#a:Type) (l:list a) : list a =
  match l with
  | _ :: xs -> xs
  | [] -> admit ()




(*! There is nothing good to put in the Nil branch : !*)
(*! we should not apply tail to empty lists ! !*)

(******************************************************************************)
(*** Refinements to the rescue ***)

let tail1 (#a:Type) (l:list a{Cons? l}) : list a =
  match l with
  | _ :: xs -> xs


(*+ l:list a{Cons? l} +*)




(*! This is also generated by F* as Cons?.hd and Cons?.tl !*)
(*! Cons?.tl l0 ~> 2 :: 3 :: [] !*)



(******************************************************************************)
(*** Examples of refinements ***)

let nat = k:int{ 0 < k }

let palindrome (a:Type) = l:list a{ l == rev l }

let valid_index (#a:Type) (l:list a) = k:nat{k < length l}

let keep_parity = f:(nat -> nat){forall (x:nat). x % 2 == f x % 2}


(******************************************************************************)
(*** Proving things ***)

let length_cons (#a:Type) (x:a) (l:list a)
  : Lemma (length (x :: l) == 1 + length l)
= ()

(*! The fact is trivial and the proof is too !*)
(*! What about proving that map preserves length !*)

let length_map0 (#a #b:Type) (f:a -> b) (l:list a)
  : Lemma (length (map f l) == length l)
= admit ()

(******************************************************************************)
(*** Proving interesting things ***)

let rec length_map (#a #b:Type) (f:a -> b) (l:list a)
  : Lemma (ensures (length (map f l) == length l))
= match l with
  | [] -> ()
  | _ :: xs -> length_map f xs

(*+ Most of the work is done by the smt solver +*)
(*+ We only need to provide the skeleton of the proof here +*)

(*! In pratice : set up the skeleton with admit !*)

(******************************************************************************)
(*+ Termination +*)


let rec foldl (#a #b:Type) (f : a -> b -> a) (acc:a) (l:list b)
  : Tot a (decreases l)
= match l with
  | [] -> acc
  | x :: xs -> foldl f (f acc x) xs

(*! decreases clauses gives some decreasing measure !*)
(*! it contains an arbitrary total term !*)
(*! which needs to decrease for the << relation !*)

(******************************************************************************)
(*** The << relation ***)

(*+ - strict order on Nat +*)
let _ = assert (5 << 42)
let nat_succ_ordering (n:nat) = assert (n << n +1)

(*+ - subterm of datatypes +*)
let _ = assert (3 :: [] << l0)
let list_tail_ordering (#a:Type) (l:list a{Cons? l}) =
  assert (Cons?.tl l << l)

(*+ - lexicographic ordering +*)

let _ = %[3 ; 42] << %[4 ; 4]
let _ = %[2 ; Some 3 ; 7] << %[2 ; Some 5 ; ()]
