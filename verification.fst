(*** From the standard lib ***)
module Verification

open FStar.List.Tot.Base

(* Some syntactic sugar *)
let nil = []
let cons x xs = x :: xs

let l0 = 1 :: 2 :: 3 :: []

(*+ Discriminators : Nil?, Cons? +*)
(*! Nil? l0 ~> false !*)
(*! Cons? l0 ~> true !*)

(******************************************************************************)
(*** Off with their heads ***)


(* What about getting the tail of a list ? *)
let tail0 (#a:Type) (l:list a) : list a =
  match l with
  | _ :: xs -> xs
  | [] -> admit ()



(*! There is nothing good to put in the Nil branch : !*)
(*! we should not apply tail to empty lists ! !*)

(******************************************************************************)
(*** Refinements to the rescue ***)


let tail1 (#a:Type) (l:list a{Cons? l}) : list a =
  match l with
  | _ :: xs -> xs


(*+ l:list a{Cons? l} +*)



(*! This is also generated by F* as Cons?.hd and Cons?.tl !*)
(*! Cons?.tl l0 ~> 2 :: 3 :: [] !*)



(******************************************************************************)
(*** Examples of refinements ***)

let nat' = k:int{ 0 <= k }

let palindrome (a:Type) = l:list a{ l == rev l }

let valid_index (#a:Type) (l:list a) = k:nat{k < length l}

let keep_parity = f:(nat -> nat){forall (x:nat). x % 2 == f x % 2}

(*! Refinements generate a subtyping relation <: !*)
(*! x:a{p x} <: a !*)

(******************************************************************************)
(*** Pure ***)

let tail2 (a:Type) (l:list a)
  : Pure (list a)
    (requires (Cons? l))
    (ensures (fun _ -> True))
= match l with
  | _ :: xs -> xs

(*+ Pure type precondition postcondition +*)

(******************************************************************************)
(*** Formulas ***)

let formula = Type0

let phi1 (n:int) = n < 3 \/ (n > 27 ==> n % 2 == 0)

let phi2 = forall (l:list int). Cons? l ==> Cons?.hd l == 5

let phi3 = forall (l:list int). exists (x:int). l == [] \/ Cons?.hd l == x

let bool_as_formula (b:bool) = b == true (* standard name : b2t *)

(******************************************************************************)
(*** Proving things ***)

let length_cons (#a:Type) (x:a) (l:list a)
  : Lemma (length (x :: l) == 1 + length l)
= ()

(*! The fact is trivial and the proof is too !*)
(*! What about proving that map preserves length ? !*)

let length_map0 (#a #b:Type) (f:a -> b) (l:list a)
  : Lemma (length (map f l) == length l)
= admit ()

(******************************************************************************)
(*** Proving interesting things ***)

let rec length_map (#a #b:Type) (f:a -> b) (l:list a)
  : Lemma (ensures (length (map f l) == length l))
= match l with
  | [] -> ()
  | _ :: xs -> length_map f xs

(*+ Most of the work is done by the smt solver +*)
(*+ We only need to provide the skeleton of the proof here +*)

(*! In pratice : set up the skeleton with admit !*)

let rec append_length_lemma (#a:Type) (l1 l2:list a)
  : Pure unit
    (requires True)
    (ensures (fun () -> length (l1 `append` l2) == length l1 + length l2))
= admit ()

(******************************************************************************)
(*** Termination ***)


let rec foldl (#a #b:Type) (f : a -> b -> a) (acc:a) (l:list b)
  : Tot a (decreases (length l))
= match l with
  | [] -> acc
  | x :: xs -> foldl f (f acc x) xs

// let vc = length xs << length l


(*! decreases clauses gives some decreasing measure !*)
(*! it contains an arbitrary total term !*)
(*! which needs to decrease for the << relation !*)

(******************************************************************************)
(*** The << relation ***)

(*+ - strict order on Nat +*)
let _ = assert (5 << 42)
let nat_succ_ordering (n:nat) = assert (n << n +1)

(*+ - subterm of datatypes +*)
let _ = assert (3 :: [] << l0)
let list_tail_ordering (#a:Type) (l:list a{Cons? l}) =
  assert (Cons?.tl l << l)

(*+ - lexicographic ordering +*)

let _ = assert (%[3 ; 42] << %[4 ; 4])
let _ = assert (%[2 ; 3 ; 7] << %[2 ; 5 ; ()])

(******************************************************************************)
(*** Let's try it out ***)


val length: list 'a -> Tot nat
let rec length l = match l with
  | [] -> 0 <: nat
  | _ :: tl -> 1 + length tl

val append : list 'a -> list 'a -> Tot (list 'a)
let rec append l1 l2 = match l1 with
  | [] -> l2
  | hd :: tl -> hd :: append tl l2

(* Prove this lemma *)
val append_len: l1:list 'a -> l2:list 'a ->
  Lemma (requires True)
    (ensures (length (append l1 l2) = length l1 + length l2))
let rec append_len l1 l2 = admit()


(******************************************************************************)
(*** Proving an equality ***)

val reverse: list 'a -> Tot (list 'a)
let rec reverse l =
  match l with
  | [] -> []
  | hd::tl -> append (reverse tl) [hd]
let snoc l h = append l [h]

val snoc_cons: l:list 'a -> h:'a -> Lemma (reverse (snoc l h) == h::reverse l)
let rec snoc_cons l h = match l with
  | [] -> ()
  | hd::tl -> snoc_cons tl h


val rev_involutive: l:list 'a -> Lemma (reverse (reverse l) == l)
let rec rev_involutive l = match l with
  | [] -> ()
  | hd::tl -> rev_involutive tl; snoc_cons (reverse tl) hd

val rev_injective : l1:list 'a -> l2:list 'a
                  -> Lemma (requires (reverse l1 == reverse l2))
                          (ensures  (l1 == l2))
